// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package storage

import (
	"context"
	"database/sql"
	"time"
)

const addPaidMonthly = `-- name: AddPaidMonthly :exec
INSERT INTO paid_monthly
    (worker_id, date, paid_price)
VALUES 
    ($1, $2, $3)
`

type AddPaidMonthlyParams struct {
	WorkerID  int32
	Date      time.Time
	PaidPrice float64
}

func (q *Queries) AddPaidMonthly(ctx context.Context, arg AddPaidMonthlyParams) error {
	_, err := q.db.ExecContext(ctx, addPaidMonthly, arg.WorkerID, arg.Date, arg.PaidPrice)
	return err
}

const addWorker = `-- name: AddWorker :exec
INSERT INTO workers
    (first_name, last_name, phone)
VALUES 
    ($1, $2, $3)
`

type AddWorkerParams struct {
	FirstName string
	LastName  string
	Phone     string
}

func (q *Queries) AddWorker(ctx context.Context, arg AddWorkerParams) error {
	_, err := q.db.ExecContext(ctx, addWorker, arg.FirstName, arg.LastName, arg.Phone)
	return err
}

const deleteWorkers = `-- name: DeleteWorkers :exec
UPDATE workers
SET deleted_at = $2
WHERE id = $1
`

type DeleteWorkersParams struct {
	ID        int32
	DeletedAt sql.NullInt32
}

func (q *Queries) DeleteWorkers(ctx context.Context, arg DeleteWorkersParams) error {
	_, err := q.db.ExecContext(ctx, deleteWorkers, arg.ID, arg.DeletedAt)
	return err
}

const endDay = `-- name: EndDay :one
INSERT INTO daily_production
    (date, count_blocks)
VALUES 
    ($1, $2)
RETURNING id
`

type EndDayParams struct {
	Date        time.Time
	CountBlocks int32
}

func (q *Queries) EndDay(ctx context.Context, arg EndDayParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, endDay, arg.Date, arg.CountBlocks)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const endDayDataMonthlyReport = `-- name: EndDayDataMonthlyReport :many
WITH worker_blocks AS (
    -- Get all production IDs where the worker participated
    SELECT 
        dp.id,
        dpw.daily_production_id,
        dp.date,
        dp.count_blocks
    FROM 
        daily_production_workers dpw
    JOIN 
        daily_production dp ON dpw.daily_production_id = dp.id
    WHERE 
        dpw.worker_id = CAST($1 AS INTEGER)
        AND dpw.deleted_at = 0
        AND dp.deleted_at = 0
        AND EXTRACT(YEAR FROM dp.date) = CAST($2 AS INTEGER)
        AND EXTRACT(MONTH FROM dp.date) = CAST($3 AS INTEGER)
),
production_stats AS (
    -- Count workers for each production
    SELECT 
        dpw.daily_production_id,
        COUNT(dpw.worker_id) AS worker_count
    FROM 
        daily_production_workers dpw
    WHERE 
        dpw.deleted_at = 0
    GROUP BY 
        dpw.daily_production_id
)
SELECT 
    wb.daily_production_id,
    wb.date,
    wb.count_blocks AS total_blocks,
    ps.worker_count,
    ROUND(wb.count_blocks::NUMERIC / ps.worker_count, 1) AS worker_share,
    ROUND((wb.count_blocks::NUMERIC / ps.worker_count) * 600, 1) AS worker_payment
FROM 
    worker_blocks wb
JOIN 
    production_stats ps ON wb.daily_production_id = ps.daily_production_id
ORDER BY 
    wb.date
`

type EndDayDataMonthlyReportParams struct {
	Column1 int32
	Column2 int32
	Column3 int32
}

type EndDayDataMonthlyReportRow struct {
	DailyProductionID int32
	Date              time.Time
	TotalBlocks       int32
	WorkerCount       int64
	WorkerShare       string
	WorkerPayment     string
}

func (q *Queries) EndDayDataMonthlyReport(ctx context.Context, arg EndDayDataMonthlyReportParams) ([]EndDayDataMonthlyReportRow, error) {
	rows, err := q.db.QueryContext(ctx, endDayDataMonthlyReport, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EndDayDataMonthlyReportRow
	for rows.Next() {
		var i EndDayDataMonthlyReportRow
		if err := rows.Scan(
			&i.DailyProductionID,
			&i.Date,
			&i.TotalBlocks,
			&i.WorkerCount,
			&i.WorkerShare,
			&i.WorkerPayment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const endDayWorkers = `-- name: EndDayWorkers :exec
INSERT INTO daily_production_workers
    (daily_production_id, worker_id)
VALUES 
    ($1, $2)
`

type EndDayWorkersParams struct {
	DailyProductionID int32
	WorkerID          int32
}

func (q *Queries) EndDayWorkers(ctx context.Context, arg EndDayWorkersParams) error {
	_, err := q.db.ExecContext(ctx, endDayWorkers, arg.DailyProductionID, arg.WorkerID)
	return err
}

const getDailyProductionWorkersNameById = `-- name: GetDailyProductionWorkersNameById :many
SELECT 
    w.id,
    w.first_name,
    w.last_name
FROM 
    daily_production_workers dpw
JOIN 
    workers w ON dpw.worker_id = w.id
WHERE 
    dpw.daily_production_id = $1 
    AND dpw.deleted_at = 0
    AND w.deleted_at = 0
`

type GetDailyProductionWorkersNameByIdRow struct {
	ID        int32
	FirstName string
	LastName  string
}

func (q *Queries) GetDailyProductionWorkersNameById(ctx context.Context, dailyProductionID int32) ([]GetDailyProductionWorkersNameByIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getDailyProductionWorkersNameById, dailyProductionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyProductionWorkersNameByIdRow
	for rows.Next() {
		var i GetDailyProductionWorkersNameByIdRow
		if err := rows.Scan(&i.ID, &i.FirstName, &i.LastName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkers = `-- name: GetWorkers :many
SELECT 
    id, first_name, last_name, phone, created_at, updated_at, deleted_at
FROM
    workers
WHERE
    deleted_at = 0
`

func (q *Queries) GetWorkers(ctx context.Context) ([]Worker, error) {
	rows, err := q.db.QueryContext(ctx, getWorkers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Worker
	for rows.Next() {
		var i Worker
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Phone,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadBlockWorkers = `-- name: LoadBlockWorkers :exec
INSERT INTO load_production
    (send_block_id, worker_id)
VALUES 
    ($1, $2)
`

type LoadBlockWorkersParams struct {
	SendBlockID int32
	WorkerID    int32
}

func (q *Queries) LoadBlockWorkers(ctx context.Context, arg LoadBlockWorkersParams) error {
	_, err := q.db.ExecContext(ctx, loadBlockWorkers, arg.SendBlockID, arg.WorkerID)
	return err
}

const loadBlocksDataMonthlyReport = `-- name: LoadBlocksDataMonthlyReport :many
WITH worker_payments AS (
    SELECT
        sb.id,
        lp.worker_id,
        sb.date,
        sb.count_blocks AS total_blocks,
        sb.address,
        COUNT(DISTINCT lp2.worker_id) AS worker_count,
        ROUND(sb.count_blocks::NUMERIC / COUNT(DISTINCT lp2.worker_id), 1) AS blocks_per_worker,
        sb.load_price AS price_per_block,
        ROUND((sb.count_blocks::NUMERIC / COUNT(DISTINCT lp2.worker_id)) * sb.load_price, 1) AS payment
    FROM 
        load_production lp
    JOIN 
        send_blocks sb ON lp.send_block_id = sb.id
    JOIN 
        load_production lp2 ON lp.send_block_id = lp2.send_block_id
    WHERE 
        lp.worker_id = CAST($1 AS INTEGER)
        AND EXTRACT(YEAR FROM sb.date) = CAST($2 AS INTEGER)
        AND EXTRACT(MONTH FROM sb.date) = CAST($3 AS INTEGER)
    GROUP BY 
        lp.worker_id, sb.id, sb.date, sb.count_blocks, sb.address, sb.load_price
)
SELECT 
    id as send_block_id,
    worker_id,
    date,
    address,
    total_blocks,
    worker_count,
    ROUND(blocks_per_worker, 1) AS blocks_per_worker,  -- Soddalashtirilgan
    price_per_block,
    ROUND(payment, 1) AS payment,  -- Soddalashtirilgan
    ROUND(SUM(payment) OVER (), 1) AS total_payment  -- To'g'ri hisoblash
FROM 
    worker_payments
`

type LoadBlocksDataMonthlyReportParams struct {
	Column1 int32
	Column2 int32
	Column3 int32
}

type LoadBlocksDataMonthlyReportRow struct {
	SendBlockID     int32
	WorkerID        int32
	Date            time.Time
	Address         string
	TotalBlocks     int32
	WorkerCount     int64
	BlocksPerWorker string
	PricePerBlock   int32
	Payment         string
	TotalPayment    string
}

func (q *Queries) LoadBlocksDataMonthlyReport(ctx context.Context, arg LoadBlocksDataMonthlyReportParams) ([]LoadBlocksDataMonthlyReportRow, error) {
	rows, err := q.db.QueryContext(ctx, loadBlocksDataMonthlyReport, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoadBlocksDataMonthlyReportRow
	for rows.Next() {
		var i LoadBlocksDataMonthlyReportRow
		if err := rows.Scan(
			&i.SendBlockID,
			&i.WorkerID,
			&i.Date,
			&i.Address,
			&i.TotalBlocks,
			&i.WorkerCount,
			&i.BlocksPerWorker,
			&i.PricePerBlock,
			&i.Payment,
			&i.TotalPayment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const paidMonthlyData = `-- name: PaidMonthlyData :many
SELECT 
    worker_id,
    date,
    paid_price,
    created_at
FROM 
    paid_monthly
WHERE 
    worker_id = CAST($1 AS INTEGER)
    AND EXTRACT(YEAR FROM date) = CAST($2 AS INTEGER)
    AND EXTRACT(MONTH FROM date) = CAST($3 AS INTEGER)
    AND deleted_at = 0
ORDER BY 
    date
`

type PaidMonthlyDataParams struct {
	Column1 int32
	Column2 int32
	Column3 int32
}

type PaidMonthlyDataRow struct {
	WorkerID  int32
	Date      time.Time
	PaidPrice float64
	CreatedAt sql.NullTime
}

func (q *Queries) PaidMonthlyData(ctx context.Context, arg PaidMonthlyDataParams) ([]PaidMonthlyDataRow, error) {
	rows, err := q.db.QueryContext(ctx, paidMonthlyData, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaidMonthlyDataRow
	for rows.Next() {
		var i PaidMonthlyDataRow
		if err := rows.Scan(
			&i.WorkerID,
			&i.Date,
			&i.PaidPrice,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sendBlocks = `-- name: SendBlocks :one
INSERT INTO send_blocks
    (date, count_blocks, address, load_price)
VALUES 
    ($1, $2, $3, $4)
RETURNING id
`

type SendBlocksParams struct {
	Date        time.Time
	CountBlocks int32
	Address     string
	LoadPrice   int32
}

func (q *Queries) SendBlocks(ctx context.Context, arg SendBlocksParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, sendBlocks,
		arg.Date,
		arg.CountBlocks,
		arg.Address,
		arg.LoadPrice,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateWorkers = `-- name: UpdateWorkers :exec
UPDATE workers 
SET first_name = $2, last_name = $3, phone = $4
WHERE id = $1
`

type UpdateWorkersParams struct {
	ID        int32
	FirstName string
	LastName  string
	Phone     string
}

func (q *Queries) UpdateWorkers(ctx context.Context, arg UpdateWorkersParams) error {
	_, err := q.db.ExecContext(ctx, updateWorkers,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Phone,
	)
	return err
}
